//@version=5
// ============================================================================
// Atlas Apex 2.3 — Sprint-2 (CTS Core + Eff Maps + Cooldown)
// Build: S2-a1b2c3
// ============================================================================

// ============================= FEATURE FLAGS =============================
FF_GROUP = "Feature Flags"
ORDERS_ENABLED = input.bool(false, "Enable Order Execution", group=FF_GROUP)
QTY_GATE = input.float(0.0, "Quantity Gate (0-1)", 0.0, 1.0, 0.05, group=FF_GROUP)
FF_RV  = input.bool(true,  "FF: Regime Vector", group=FF_GROUP)
FF_PID = input.bool(false, "FF: PID Risk", group=FF_GROUP)
FF_SANDBOX = input.bool(false, "FF: Sandbox Mode", group=FF_GROUP)
FF_RV_NL = input.bool(false, "FF: RV Non-Linear (tanh)", group=FF_GROUP)

MODE_GROUP = "Mode"
INDICATOR_MODE = input.bool(true, "Indicator Mode", group=MODE_GROUP)

strategy("Atlas Apex 2.3 — Sprint-2", overlay=true,
     initial_capital=10000,
     commission_type=strategy.commission.percent,
     commission_value=0.075,
     slippage=2,
     pyramiding=0,
     calc_on_order_fills=true,
     max_bars_back=5000)

// ============================= HELPERS =============================
clamp(v, lo, hi) => math.min(math.max(v, lo), hi)

int request_count = 0
int plot_count = 0
float runtime_ms = na
int sandbox_warn_count = 0

BUILD_TAG = input.string("S2-a1b2c3", "Build Tag", group="Display")

f_sandbox_warn(cond) => FF_SANDBOX and cond ? 1 : 0

noRepaintHTF(expr, tf) =>
    request.security(syminfo.tickerid, tf, expr[1], lookahead=barmerge.lookahead_on)

htfEMA(src, len, tf) => noRepaintHTF(ta.ema(src, len), tf)

var float risk_score = 0.5
var float entropy_final = 0.5

// ============================= DEFAULTS =============================
HURST_HI = input.float(0.55, "Hurst High", group="Defaults")
HURST_LO = input.float(0.45, "Hurst Low", group="Defaults")
RV_SMOOTH_EMA = input.int(3, "RV Smooth EMA", minval=1, group="Defaults")

// ============================= SPRINT-1 INPUTS =============================
groupS1 = "Sprint-1"
RISK_OFF_ENTER = input.float(0.95, "Risk-Off Enter", 0.80, 1.00, 0.01, group=groupS1)
RISK_OFF_EXIT = input.float(0.85, "Risk-Off Exit", 0.70, 0.95, 0.01, group=groupS1)
ATTEN_FLOOR = input.float(0.60, "Attenuation Floor", 0.40, 0.80, 0.05, group=groupS1)
REL_VALVE_ENABLED = input.bool(true, "Risk-Off Early-Release", group=groupS1)
FUSE_BARS = input.int(40, "Risk-Off Fuse (bars)", 5, 200, group=groupS1)

AC_MIN_ATR_Z = input.float(0.20, "Anti-Chop: Min ATR-z", 0.00, 1.00, 0.01, group=groupS1)
AC_SIDE_GAP_ATR = input.float(0.50, "Anti-Chop: Side-gap", 0.10, 2.00, 0.05, group=groupS1)
AC_BURST_LEN = input.int(12, "Anti-Chop: Burst window", 4, 50, 1, group=groupS1)
AC_MAX_BURSTS = input.int(3, "Anti-Chop: Max flips", 1, 10, 1, group=groupS1)

NEUTRAL_LO = input.float(0.48, "Neutral Band Lower", 0.0, 0.5, 0.01, group=groupS1)
NEUTRAL_HI = input.float(0.52, "Neutral Band Upper", 0.5, 1.0, 0.01, group=groupS1)

// ============================= SPRINT-2 INPUTS =============================
groupS2 = "Sprint-2"
CD_WIN = input.int(34, "Cooldown Window (bars)", 8, 100, group=groupS2)
CD_FLIP_THRESH = input.int(4, "Cooldown Flip Threshold", 2, 20, group=groupS2)

// ============================= META (H/E/K + Winsor) =============================
ret = math.log(close/close[1])

f_hurst_simple(length) =>
    if bar_index < length
        0.5
    else
        mean_ret = ta.sma(ret, length)
        csum = 0.0, mx = 0.0, mn = 0.0
        for i = 0 to length-1
            csum := csum + (ret[i]-mean_ret)
            mx := math.max(mx, csum)
            mn := math.min(mn, csum)
        R = mx - mn, S = ta.stdev(ret, length)
        R>0 and S>0 ? clamp(math.log(R/S)/math.log(length*0.5), 0, 1) : 0.5

H_raw = FF_RV ? f_hurst_simple(50) : 0.5

// Winsor H
H_p95 = ta.percentile_linear_interpolation(H_raw, 256, 95)
H_p05 = ta.percentile_linear_interpolation(H_raw, 256, 5)
H = bar_index >= 256 ? math.min(math.max(H_raw, H_p05), H_p95) : H_raw

f_entropy5(src, lb) =>
    var float[] bins = array.new_float(5, 0)
    min_ret = ta.lowest(src, lb), max_ret = ta.highest(src, lb)
    rng = max_ret - min_ret
    e = 0.0
    if rng > 0
        for i = 0 to 4
            array.set(bins, i, 0)
        for i = 0 to lb-1
            if not na(src[i])
                idx = math.min(int((src[i]-min_ret)/rng*5), 4)
                array.set(bins, idx, array.get(bins, idx)+1)
        for i = 0 to 4
            p = array.get(bins, i)/lb
            if p>0
                e := e - p*math.log(p)
        e := e/math.log(5.0)
    else
        e := 0.5
    e

E_raw = FF_RV ? f_entropy5(ret, 100) : 0.5
E_smooth = ta.ema(E_raw, 5)

// Winsor E
E_p95 = ta.percentile_linear_interpolation(E_smooth, 256, 95)
E_p05 = ta.percentile_linear_interpolation(E_smooth, 256, 5)
E = bar_index >= 256 ? math.min(math.max(E_smooth, E_p05), E_p95) : E_smooth
entropy_final := E

mu_t = ta.sma(ret, 100)
sd_t = math.max(ta.stdev(ret, 100), 1e-8)
z_t = (ret - mu_t)/sd_t
K_raw = FF_RV ? ta.ema(math.abs(z_t), 5) : 0.0
K_pr = clamp(ta.percentrank(K_raw, 200)/100.0, 0.0, 1.0)

// Winsor K
K_p95 = ta.percentile_linear_interpolation(K_pr, 256, 95)
K_p05 = ta.percentile_linear_interpolation(K_pr, 256, 5)
K_w = bar_index >= 256 ? math.min(math.max(K_pr, K_p05), K_p95) : K_pr
K = math.max(K_w, 0.0)  // Floor at 0.0

// ============================= RV + normW =============================
wH = input.float(0.40, "wH", step=0.05, group="RV Weights")
wE = input.float(0.35, "wE", step=0.05, group="RV Weights")
wK = input.float(0.25, "wK", step=0.05, group="RV Weights")

normW(a, b, c) =>
    s = a + b + c
    s_safe = math.max(s, 1e-8)
    [a/s_safe, b/s_safe, c/s_safe]

[wH_n, wE_n, wK_n] = normW(wH, wE, wK)

Hn = clamp((H - 0.30)/0.40, 0, 1)
En = clamp(E, 0, 1)
Kn = clamp(K, 0, 1)
RV_raw = FF_RV ? (wH_n*Hn + wE_n*(1.0 - En) + wK_n*(1.0 - Kn)) : 0.5
RV = ta.ema(RV_raw, RV_SMOOTH_EMA)
risk_score := RV

rv_fast = ta.ema(RV, 3)
rv_slow = ta.ema(RV, 21)
rv_mom = rv_fast - rv_slow

// ============================= FSM =============================
var bool risk_off_state = false
var int riskoff_fuse = 0
var int ro_bars = 0
var int rn_bars = 0

_enter_th = RISK_OFF_ENTER
_exit_th = RISK_OFF_EXIT

if RV > _enter_th
    ro_bars := ro_bars + 1
    rn_bars := 0
else if RV < _exit_th or rv_mom < 0
    rn_bars := rn_bars + 1
    ro_bars := 0
else
    ro_bars := 0
    rn_bars := 0

if not risk_off_state and ro_bars >= 2
    risk_off_state := true
    riskoff_fuse := FUSE_BARS
else if risk_off_state
    riskoff_fuse := math.max(riskoff_fuse - 1, 0)
    early_release = REL_VALVE_ENABLED and riskoff_fuse == 0 and (RV < (_enter_th - 0.07)) and (rv_mom < -0.04)
    if rn_bars >= 2 or early_release
        risk_off_state := false
        rn_bars := 0
        riskoff_fuse := 0

global_damp = risk_off_state ? ATTEN_FLOOR : ATTEN_FLOOR + (1.0-ATTEN_FLOOR)*(1.0 - RV)

// ============================= ANTI-CHOP =============================
atr14 = ta.atr(14)
atr_mu50 = ta.sma(atr14, 50)
atr_sd50 = math.max(ta.stdev(atr14, 50), 1e-8)
atr_z = (atr14 - atr_mu50)/atr_sd50
atr_ratio = atr14 / math.max(atr_mu50, 1e-8)

// ============================= EFF MAPS (RV → len/mult) =============================
// Linear base mapping
f_map_lin(rv, lo, hi) => lo + rv * (hi - lo)

// Tanh alternative (non-linear) - manual implementation
f_tanh(x) =>
    e2x = math.exp(2 * x)
    (e2x - 1) / (e2x + 1)

f_map_tanh(rv, lo, hi, steep) =>
    mid = (lo + hi) * 0.5
    rng = (hi - lo) * 0.5
    x = (rv - 0.5) * steep
    mid + rng * f_tanh(x)

// Len mappings
len_pt_base = FF_RV_NL ? f_map_tanh(RV, 9.0, 55.0, 4.0) : f_map_lin(RV, 9.0, 55.0)
len_ma_base = FF_RV_NL ? f_map_tanh(RV, 7.0, 34.0, 4.0) : f_map_lin(RV, 7.0, 34.0)

len_pt_eff = math.round(clamp(len_pt_base, 9, 55))
len_ma_eff = math.round(clamp(len_ma_base, 7, 34))

// Mult mappings
mult_pt_base = FF_RV_NL ? f_map_tanh(RV, 0.7, 1.4, 4.0) : f_map_lin(RV, 0.7, 1.4)
mult_xv_base = FF_RV_NL ? f_map_tanh(RV, 0.8, 1.4, 4.0) : f_map_lin(RV, 0.8, 1.4)
mult_dv_base = FF_RV_NL ? f_map_tanh(RV, 0.8, 1.4, 4.0) : f_map_lin(RV, 0.8, 1.4)

mult_pt_eff = clamp(mult_pt_base, 0.7, 1.4)
mult_xv_eff = clamp(mult_xv_base, 0.8, 1.4)
mult_dv_eff = clamp(mult_dv_base, 0.8, 1.4)

// ============================= CTS COMPOSITE (Stage-A) =============================
// Weights (Stage-A preset)
w_pt = 0.40
w_ma = 0.30
w_lt = 0.15
w_xv = 0.10
w_dv = 0.05

// normW for CTS weights
[w_pt_n, w_ma_n, w_lt_n] = normW(w_pt, w_ma, w_lt)
[w_xv_n, w_dv_n, _unused] = normW(w_xv, w_dv, 0.0)
w_sum_cts = w_pt_n + w_ma_n + w_lt_n + w_xv_n + w_dv_n

// ATR-safe reuse
atrSafe = math.max(atr14, 1e-8)

// ============================= VEMA (Variable-alpha EMA) =============================
// Dynamic alpha from RV-mapped lengths
alpha_pt = 2.0 / (math.max(len_pt_eff, 1.0) + 1.0)
alpha_ma = 2.0 / (math.max(len_ma_eff, 1.0) + 1.0)

// VEMA state (budget-neutral: no new security/plot calls)
var float vema_pt = na
var float vema_ma = na

// Seed & update
vema_pt := na(vema_pt[1]) ? close : alpha_pt * close + (1.0 - alpha_pt) * vema_pt[1]
vema_ma := na(vema_ma[1]) ? close : alpha_ma * close + (1.0 - alpha_ma) * vema_ma[1]

// L1 Trend components
ema_pt = vema_pt
slope_pt = (ema_pt - ema_pt[1]) / atrSafe

macd_raw = ta.ema(close, 12) - ta.ema(close, 26)  // Fixed lengths, normal EMA
mom_ma = (macd_raw - macd_raw[1]) / atrSafe

lt_line = ta.ema(close, 55)  // Fixed length, normal EMA
trend_lt = math.sign(ema_pt - lt_line) * 1.0

// L2 Mean-Rev components
ema_ma = vema_ma
dev_ema = (close - ema_ma) / atrSafe

// CTS composite
cts_raw = w_pt_n * slope_pt + w_ma_n * mom_ma + w_lt_n * trend_lt - w_xv_n * math.abs(atr_z) - w_dv_n * math.abs(dev_ema)
cts_final = ta.ema(cts_raw, 3)

// Flip detection
flip = math.sign(nz(cts_final)) != math.sign(nz(cts_final[1])) and math.sign(nz(cts_final)) != 0

// ============================= COOLDOWN (Flip-based) =============================
// Manual rolling sum (ta.sum not available in Pine v5)
f_rolling_sum(cond, len) =>
    sum = 0
    for i = 0 to len - 1
        if cond[i]
            sum := sum + 1
    sum

flip_cnt = f_rolling_sum(flip, CD_WIN)
cooldown_flag = flip_cnt >= CD_FLIP_THRESH

// ============================= ANTI-CHOP (updated) =============================
ema20 = ta.ema(close, 20)
ext = (close - ema20)/atrSafe
ext_abs = math.abs(ext)

side_gap_ok_long = (ema20 - low) >= AC_SIDE_GAP_ATR * atr14
side_gap_ok_short = (high - ema20) >= AC_SIDE_GAP_ATR * atr14

var int burst_flips = 0
var int burst_window = 0
var float last_sign = 0.0

cts_sign = math.sign(cts_final)
burst_flip = cts_sign != 0 and cts_sign != math.sign(nz(last_sign))
if burst_flip
    burst_flips := burst_flips + 1
if cts_sign != 0
    last_sign := cts_sign
burst_window := burst_window + 1
if burst_window >= AC_BURST_LEN
    burst_window := 0
    burst_flips := 0

// ============================= HTF =============================
htf_close = noRepaintHTF(close, "60")
request_count := request_count + 1

htf_ema20 = noRepaintHTF(ta.ema(close, 20), "60")
request_count := request_count + 1

sandbox_warn_count := sandbox_warn_count + f_sandbox_warn(na(htf_ema20))
budget_ok_check = (request_count <= 35) and (plot_count <= 64)
sandbox_warn_count := sandbox_warn_count + f_sandbox_warn(not budget_ok_check)

// ============================= GATES =============================
base_gate = atr_ratio > 1.30 ? 2.2 : 2.0
gate_enter = base_gate + 0.15
gate_exit = base_gate - 0.15

var bool need_htf_state = false
if not need_htf_state and ext_abs > gate_enter
    need_htf_state := true
else if need_htf_state and ext_abs < gate_exit
    need_htf_state := false

htf_ok = cts_final > 0 ? (close > htf_ema20) : (close < htf_ema20)
gate5_pass = (not need_htf_state) or htf_ok

ext_gate = base_gate
pb_long = (close <= ema20 + 0.5*atr14) or (close < open)
pb_short = (close >= ema20 - 0.5*atr14) or (close > open)
gate1_pass = (ext_abs <= ext_gate) or (pb_long and side_gap_ok_long) or (pb_short and side_gap_ok_short)

dcts = ta.change(cts_final)
cts_pr = nz(ta.percentrank(cts_final, 200)/100.0, 0.5)
gate2_pass = cts_final > 0 ? (cts_pr <= 0.95 and dcts >= 0) : (cts_pr >= 0.05 and dcts <= 0)

jsd_high = E >= 0.85
gate3_pass = not (jsd_high or (atr_z < AC_MIN_ATR_Z) or (burst_flips > AC_MAX_BURSTS))

blocked_by_risk = risk_off_state
blocked_by_neutral = math.abs(cts_final) >= NEUTRAL_LO and math.abs(cts_final) <= NEUTRAL_HI

// Gate composite with cooldown
gates_ok = gate1_pass and gate2_pass and gate3_pass and gate5_pass and not cooldown_flag

// ============================= DVL + PR90 =============================
dvl_num = ta.stdev(cts_final, 34)
dvl_den = ta.stdev(cts_final, 288)
DVL_raw = dvl_num / math.max(dvl_den, 1e-8)
DVL = bar_index < 300 ? na : clamp(DVL_raw, 0.0, 1.0)

// Extract percentile call from ternary for consistency
DVL_pr90_calc = ta.percentile_linear_interpolation(nz(DVL, 0.0), 288, 90)
DVL_pr90 = bar_index >= 288 ? DVL_pr90_calc : na
dvl_label = na(DVL) ? "warmup" : (DVL > DVL_pr90 ? "YÜKSEK" : "NORMAL")

// ============================= EXECUTION =============================
allow_orders = ORDERS_ENABLED and QTY_GATE > 0.0
unit_final = 1.0
unit_final_gated = unit_final * QTY_GATE

long_signal = false
short_signal = false

if allow_orders
    na

// ============================= TELEMETRY =============================
groupDisp = "Display"
SHOW_TABLE = input.bool(true, "Show Telemetry", group=groupDisp)
SHOW_RISK_BG = input.bool(true, "Show Risk BG", group=groupDisp)
COMPACT_VIEW = input.bool(false, "Compact", group=groupDisp)
LIVE_TICK_UPDATES = input.bool(true, "Telemetry: Update Every Tick", group=groupDisp)
SHOW_G5_DBG = input.bool(false, "Show G5 Debug (Row-13)", group=groupDisp)

bgcolor(SHOW_RISK_BG and risk_off_state ? color.new(color.red, 95) : na)

basis_ema = ta.ema(close, 21)
plot(basis_ema, "Basis EMA", color.new(color.blue,70))
plot_count := plot_count + 1

plot(htf_ema20, "HTF EMA20", color.new(color.orange, 80))
plot_count := plot_count + 1

// ============================= TABLE =============================
var table t = na

if SHOW_TABLE and na(t)
    t := table.new(position.top_right, 2, COMPACT_VIEW?12:34, 
         bgcolor=color.new(color.black,80), border_color=color.gray, border_width=1)

should_draw = SHOW_TABLE and (barstate.islast or (LIVE_TICK_UPDATES and barstate.isrealtime))
if should_draw
    
    // Row-0: Header + Build
    banner = "ATLAS Apex 2.3 — Sprint-2 | Pine:v5 | Build:" + BUILD_TAG
    table.cell(t, 0, 0, banner, text_color=color.white, bgcolor=color.new(color.blue, 50), text_size=size.small)
    table.cell(t, 1, 0, "VALUE", text_color=color.white, bgcolor=color.new(color.blue, 50))
    
    table.cell(t,0,1,"H",text_color=color.white)
    table.cell(t,1,1,str.tostring(H,"#.###"))
    table.cell(t,0,2,"E",text_color=color.white)
    table.cell(t,1,2,str.tostring(E,"#.###"))
    table.cell(t,0,3,"K",text_color=color.white)
    table.cell(t,1,3,str.tostring(K,"#.###"))
    table.cell(t,0,4,"RV",text_color=color.white)
    table.cell(t,1,4,str.tostring(RV,"#.###"))
    table.cell(t,0,5,"global_damp",text_color=color.white)
    table.cell(t,1,5,str.tostring(global_damp,"#.###"))
    
    mode_val = allow_orders ? "Strategy ✓" : "Indicator"
    table.cell(t,0,6,"Mode",text_color=color.white)
    table.cell(t,1,6,mode_val)
    
    ff_val = (FF_RV?"R":"—")+"/"+(FF_PID?"P":"—")+"/"+(FF_SANDBOX?"S":"—")+"/"+(FF_RV_NL?"NL":"—")
    table.cell(t,0,7,"FF_RV/PID/SBX/NL",text_color=color.white)
    table.cell(t,1,7,ff_val)
    
    if not COMPACT_VIEW
        rv_val = str.tostring(rv_fast,"#.###")+"/"+str.tostring(rv_slow,"#.###")+"/"+str.tostring(rv_mom,"#.###")
        table.cell(t,0,8,"RVf/RVs/ΔRV",text_color=color.white)
        table.cell(t,1,8,rv_val)
        
        fsm_val = (risk_off_state?"1":"0")+" / "+str.tostring(riskoff_fuse)
        table.cell(t,0,9,"R-Off state/fuse",text_color=color.white)
        table.cell(t,1,9,fsm_val)
        
        gate_val = (gate1_pass?"✓":"×")+"/"+(gate2_pass?"✓":"×")+"/"+(gate3_pass?"✓":"×")+"/"+(gate5_pass?"✓":"×")
        table.cell(t,0,10,"G1/G2/G3/G5",text_color=color.white)
        table.cell(t,1,10,gate_val)
        
        block_val = blocked_by_risk?"risk":(blocked_by_neutral?"neutral":(cooldown_flag?"cooldown":"—"))
        table.cell(t,0,11,"blocked_by",text_color=color.white)
        table.cell(t,1,11,block_val)
        
        dvl_str = na(DVL) ? "warmup" : str.format("{0,number,#.##} (PR90:{1,number,#.##}) | {2}", DVL, nz(DVL_pr90), dvl_label)
        table.cell(t,0,12,"DVL",text_color=color.white)
        table.cell(t,1,12,dvl_str)
        
        // G5 Debug (Row-13, optional)
        g5_label = SHOW_G5_DBG ? "G5 dbg (need|ext|base)" : "G5 dbg"
        g5_value = SHOW_G5_DBG ? str.format("{0} | {1,number,#.##} | {2,number,#.##}", 
                                   need_htf_state ? "1" : "0", ext_abs, base_gate) : "—"
        table.cell(t,0,13,g5_label,text_color=color.white)
        table.cell(t,1,13,g5_value)
        
        // Sprint-2: Eff params (Rows 14-16)
        table.cell(t,0,14,"len_pt/ma_eff",text_color=color.white)
        table.cell(t,1,14,str.format("{0} / {1}", len_pt_eff, len_ma_eff))
        
        table.cell(t,0,15,"mult_pt/ma_eff",text_color=color.white)
        table.cell(t,1,15,str.format("{0,number,#.##} / —", mult_pt_eff))
        
        table.cell(t,0,16,"mult_xv/dv_eff",text_color=color.white)
        table.cell(t,1,16,str.format("{0,number,#.##} / {1,number,#.##}", mult_xv_eff, mult_dv_eff))
        
        // Sprint-2: Cooldown (Row-17)
        cd_status = cooldown_flag ? "ON" : "OFF"
        cd_cnt_str = str.tostring(flip_cnt)
        cd_win_str = str.tostring(CD_WIN)
        cd_display = cd_status + " (" + cd_cnt_str + "/" + cd_win_str + ")"
        table.cell(t,0,17,"cooldown_eff",text_color=color.white)
        table.cell(t,1,17,cd_display,text_color=cooldown_flag?color.orange:color.gray)
        
        // Sprint-2: CTS Debug (Row-18) - Manual string concat for Pine v5 compatibility
        atr_z_abs = math.abs(atr_z)
        dev_ema_abs = math.abs(dev_ema)
        cts_dbg = str.tostring(slope_pt,"#.###") + " | " + 
                  str.tostring(mom_ma,"#.###") + " | " + 
                  str.tostring(trend_lt,"#") + " | " + 
                  str.tostring(atr_z_abs,"#.###") + " | " + 
                  str.tostring(dev_ema_abs,"#.###")
        table.cell(t,0,18,"CTS dbg",text_color=color.white,text_size=size.tiny)
        table.cell(t,1,18,cts_dbg,text_size=size.tiny)
        
        table.cell(t,0,19,"Slip μ/M/P95",text_color=color.white)
        table.cell(t,1,19,"—/—/— bps")
        table.cell(t,0,20,"MFOC",text_color=color.white)
        table.cell(t,1,20,"— bps")
        table.cell(t,0,21,"Guard",text_color=color.white)
        table.cell(t,1,21,"OK")
        
        table.cell(t,0,22,"EV / err",text_color=color.white)
        table.cell(t,1,22,"— / —")
        table.cell(t,0,23,"P / I / D",text_color=color.white)
        table.cell(t,1,23,"— / — / —")
        table.cell(t,0,24,"rs_scale_eff",text_color=color.white)
        table.cell(t,1,24,"—")
        table.cell(t,0,25,"gamma_eff",text_color=color.white)
        table.cell(t,1,25,"—")
        
        rt_val = na(runtime_ms) ? "n/a" : str.tostring(runtime_ms,"#.##")
        table.cell(t,0,26,"runtime_ms",text_color=color.white)
        table.cell(t,1,26,rt_val)
        table.cell(t,0,27,"request_count",text_color=color.white)
        table.cell(t,1,27,str.tostring(request_count))
        table.cell(t,0,28,"plot_count",text_color=color.white)
        table.cell(t,1,28,str.tostring(plot_count))
        
        bud_ok = (request_count<=35) and (plot_count<=64)
        bud_val = bud_ok ? "✓ OK" : "⚠ OVERSHOOT"
        bud_col = bud_ok ? color.green : color.orange
        table.cell(t,0,29,"Budget Status",text_color=color.white)
        table.cell(t,1,29,bud_val,text_color=bud_col)
        
        sb_val = FF_SANDBOX ? str.tostring(sandbox_warn_count) : "—"
        sb_col = sandbox_warn_count>0 ? color.orange : color.gray
        table.cell(t,0,30,"Sandbox Warns",text_color=color.white)
        table.cell(t,1,30,sb_val,text_color=sb_col)
        
        htf_val = na(htf_ema20) ? "⚠ NaN" : "✓ OK"
        htf_col = na(htf_ema20) ? color.red : color.green
        table.cell(t,0,31,"HTF Status",text_color=color.white)
        table.cell(t,1,31,htf_val,text_color=htf_col)
        
        // Sprint-2: Invariants (Row-32)
        cts_sane = not na(cts_final) and math.abs(cts_final) <= 1.0
        htf_ok_inv = not na(htf_ema20)
        budget_ok_inv = (request_count == 2) and (plot_count == 2)
        inv_ok = budget_ok_inv and htf_ok_inv and cts_sane
        inv_msg = inv_ok ? "✓ PASS" : 
                  (not cts_sane ? "✗ FAIL (abs(CTS)>1)" : 
                  (not budget_ok_inv ? "✗ FAIL (budget)" : "✗ FAIL (htf)"))
        table.cell(t,0,32,"Invariants",text_color=color.white)
        table.cell(t,1,32,inv_msg,text_color=inv_ok?color.green:color.red)
        
        // Row-33: CTS final value
        table.cell(t,0,33,"cts_final",text_color=color.white)
        table.cell(t,1,33,str.tostring(cts_final,"#.####"),text_color=cts_final>0?color.green:color.red)