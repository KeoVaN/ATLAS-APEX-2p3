//@version=5
// ============================================================================
// Atlas Apex 2.3 — Sprint-1 FINAL (Budget-Safe, HTF Hygiene)
// ============================================================================

// ============================= FEATURE FLAGS =============================
FF_GROUP = "Feature Flags"
ORDERS_ENABLED = input.bool(false, "Enable Order Execution", group=FF_GROUP)
QTY_GATE = input.float(0.0, "Quantity Gate (0-1)", 0.0, 1.0, 0.05, group=FF_GROUP)
FF_RV  = input.bool(true,  "FF: Regime Vector", group=FF_GROUP)
FF_PID = input.bool(false, "FF: PID Risk", group=FF_GROUP)
FF_SANDBOX = input.bool(false, "FF: Sandbox Mode", group=FF_GROUP)

MODE_GROUP = "Mode"
INDICATOR_MODE = input.bool(true, "Indicator Mode", group=MODE_GROUP)

strategy("Atlas Apex 2.3 — Sprint-1", overlay=true,
     initial_capital=10000,
     commission_type=strategy.commission.percent,
     commission_value=0.075,
     slippage=2,
     pyramiding=0,
     calc_on_order_fills=true,
     max_bars_back=5000)

// ============================= HELPERS =============================
clamp(v, lo, hi) => math.min(math.max(v, lo), hi)

int request_count = 0
int plot_count = 0
float runtime_ms = na
int sandbox_warn_count = 0  // Reset every bar for accurate per-bar anomaly count

// Build meta (manual update per sprint - displayed in telemetry Row-0 VALUE column)
BUILD = "S1-7f8e9a2"  // Update this line on each sprint/hotfix

f_sandbox_warn(cond) => FF_SANDBOX and cond ? 1 : 0

noRepaintHTF(expr, tf) =>
    request.security(syminfo.tickerid, tf, expr[1], lookahead=barmerge.lookahead_on)

htfEMA(src, len, tf) => noRepaintHTF(ta.ema(src, len), tf)

var float risk_score = 0.5
var float entropy_final = 0.5

// ============================= DEFAULTS =============================
HURST_HI = input.float(0.55, "Hurst High", group="Defaults")
HURST_LO = input.float(0.45, "Hurst Low", group="Defaults")
RV_SMOOTH_EMA = input.int(3, "RV Smooth EMA", minval=1, group="Defaults")

// ============================= SPRINT-1 INPUTS =============================
groupS1 = "Sprint-1"
RISK_OFF_ENTER = input.float(0.95, "Risk-Off Enter", 0.80, 1.00, 0.01, group=groupS1)
RISK_OFF_EXIT = input.float(0.85, "Risk-Off Exit", 0.70, 0.95, 0.01, group=groupS1)
ATTEN_FLOOR = input.float(0.60, "Attenuation Floor", 0.40, 0.80, 0.05, group=groupS1)
REL_VALVE_ENABLED = input.bool(true, "Risk-Off Early-Release", group=groupS1)
FUSE_BARS = input.int(40, "Risk-Off Fuse (bars)", 5, 200, group=groupS1)

AC_MIN_ATR_Z = input.float(0.20, "Anti-Chop: Min ATR-z", 0.00, 1.00, 0.01, group=groupS1)
AC_SIDE_GAP_ATR = input.float(0.50, "Anti-Chop: Side-gap", 0.10, 2.00, 0.05, group=groupS1)
AC_BURST_LEN = input.int(12, "Anti-Chop: Burst window", 4, 50, 1, group=groupS1)
AC_MAX_BURSTS = input.int(3, "Anti-Chop: Max flips", 1, 10, 1, group=groupS1)

NEUTRAL_LO = input.float(0.48, "Neutral Band Lower", 0.0, 0.5, 0.01, group=groupS1)
NEUTRAL_HI = input.float(0.52, "Neutral Band Upper", 0.5, 1.0, 0.01, group=groupS1)

// ============================= META =============================
ret = math.log(close/close[1])

f_hurst_simple(length) =>
    if bar_index < length
        0.5
    else
        mean_ret = ta.sma(ret, length)
        csum = 0.0, mx = 0.0, mn = 0.0
        for i = 0 to length-1
            csum := csum + (ret[i]-mean_ret)
            mx := math.max(mx, csum)
            mn := math.min(mn, csum)
        R = mx - mn, S = ta.stdev(ret, length)
        R>0 and S>0 ? clamp(math.log(R/S)/math.log(length*0.5), 0, 1) : 0.5

H = FF_RV ? f_hurst_simple(50) : 0.5

f_entropy5(src, lb) =>
    var float[] bins = array.new_float(5, 0)
    min_ret = ta.lowest(src, lb), max_ret = ta.highest(src, lb)
    rng = max_ret - min_ret
    e = 0.0
    if rng > 0
        for i = 0 to 4
            array.set(bins, i, 0)
        for i = 0 to lb-1
            if not na(src[i])
                idx = math.min(int((src[i]-min_ret)/rng*5), 4)
                array.set(bins, idx, array.get(bins, idx)+1)
        for i = 0 to 4
            p = array.get(bins, i)/lb
            if p>0
                e := e - p*math.log(p)
        e := e/math.log(5.0)
    else
        e := 0.5
    e

E_raw = FF_RV ? f_entropy5(ret, 100) : 0.5
E = ta.ema(E_raw, 5)
entropy_final := E

mu_t = ta.sma(ret, 100)
sd_t = math.max(ta.stdev(ret, 100), 1e-8)
z_t = (ret - mu_t)/sd_t
K_raw = FF_RV ? ta.ema(math.abs(z_t), 5) : 0.0
K = clamp(ta.percentrank(K_raw, 200)/100.0, 0.0, 1.0)

wH = input.float(0.40, "wH", step=0.05, group="RV Weights")
wE = input.float(0.35, "wE", step=0.05, group="RV Weights")
wK = input.float(0.25, "wK", step=0.05, group="RV Weights")
Hn = clamp((H - 0.30)/0.40, 0, 1)
En = clamp(E, 0, 1)
Kn = clamp(K, 0, 1)
RV_raw = FF_RV ? (wH*Hn + wE*(1.0 - En) + wK*(1.0 - Kn)) : 0.5
RV = ta.ema(RV_raw, RV_SMOOTH_EMA)
risk_score := RV

rv_fast = ta.ema(RV, 3)
rv_slow = ta.ema(RV, 21)
rv_mom = rv_fast - rv_slow

// ============================= FSM =============================
var bool risk_off_state = false
var int riskoff_fuse = 0
var int ro_bars = 0
var int rn_bars = 0

_enter_th = RISK_OFF_ENTER
_exit_th = RISK_OFF_EXIT

if RV > _enter_th
    ro_bars := ro_bars + 1
    rn_bars := 0
else if RV < _exit_th or rv_mom < 0
    rn_bars := rn_bars + 1
    ro_bars := 0
else
    ro_bars := 0
    rn_bars := 0

if not risk_off_state and ro_bars >= 2
    risk_off_state := true
    riskoff_fuse := FUSE_BARS
else if risk_off_state
    riskoff_fuse := math.max(riskoff_fuse - 1, 0)
    early_release = REL_VALVE_ENABLED and riskoff_fuse == 0 and (RV < (_enter_th - 0.07)) and (rv_mom < -0.04)
    if rn_bars >= 2 or early_release
        risk_off_state := false
        rn_bars := 0
        riskoff_fuse := 0

global_damp = risk_off_state ? ATTEN_FLOOR : ATTEN_FLOOR + (1.0-ATTEN_FLOOR)*(1.0 - RV)

// ============================= ANTI-CHOP =============================
atr14 = ta.atr(14)
atr_mu50 = ta.sma(atr14, 50)
atr_sd50 = math.max(ta.stdev(atr14, 50), 1e-8)
atr_z = (atr14 - atr_mu50)/atr_sd50
atr_ratio = atr14 / math.max(atr_mu50, 1e-8)

ema20 = ta.ema(close, 20)
ext = (close - ema20)/math.max(atr14, 1e-8)
ext_abs = math.abs(ext)

side_gap_ok_long = (ema20 - low) >= AC_SIDE_GAP_ATR * atr14
side_gap_ok_short = (high - ema20) >= AC_SIDE_GAP_ATR * atr14

var int burst_flips = 0
var int burst_window = 0
var float last_sign = 0.0

cts_final = 0.0
cts_sign = math.sign(cts_final)
flip = cts_sign != 0 and cts_sign != math.sign(nz(last_sign))
if flip
    burst_flips := burst_flips + 1
if cts_sign != 0
    last_sign := cts_sign
burst_window := burst_window + 1
if burst_window >= AC_BURST_LEN
    burst_window := 0
    burst_flips := 0

// ============================= HTF =============================
htf_close = noRepaintHTF(close, "60")
request_count := request_count + 1

htf_ema20 = noRepaintHTF(ta.ema(close, 20), "60")
request_count := request_count + 1

sandbox_warn_count := sandbox_warn_count + f_sandbox_warn(na(htf_ema20))
budget_ok_check = (request_count <= 35) and (plot_count <= 64)
sandbox_warn_count := sandbox_warn_count + f_sandbox_warn(not budget_ok_check)

// ============================= GATES =============================
base_gate = atr_ratio > 1.30 ? 2.2 : 2.0
gate_enter = base_gate + 0.15
gate_exit = base_gate - 0.15

var bool need_htf_state = false
if not need_htf_state and ext_abs > gate_enter
    need_htf_state := true
else if need_htf_state and ext_abs < gate_exit
    need_htf_state := false

htf_ok = cts_final > 0 ? (close > htf_ema20) : (close < htf_ema20)
gate5_pass = (not need_htf_state) or htf_ok

ext_gate = base_gate
pb_long = (close <= ema20 + 0.5*atr14) or (close < open)
pb_short = (close >= ema20 - 0.5*atr14) or (close > open)
gate1_pass = (ext_abs <= ext_gate) or (pb_long and side_gap_ok_long) or (pb_short and side_gap_ok_short)

dcts = ta.change(cts_final)
cts_pr = nz(ta.percentrank(cts_final, 200)/100.0, 0.5)
gate2_pass = cts_final > 0 ? (cts_pr <= 0.95 and dcts >= 0) : (cts_pr >= 0.05 and dcts <= 0)

jsd_high = E >= 0.85
gate3_pass = not (jsd_high or (atr_z < AC_MIN_ATR_Z) or (burst_flips > AC_MAX_BURSTS))

blocked_by_risk = risk_off_state
blocked_by_neutral = math.abs(cts_final) >= NEUTRAL_LO and math.abs(cts_final) <= NEUTRAL_HI
blocked_by_cooldown = false

// ============================= DVL (Diagnostic Volatility Level) =============================
dvl_num = ta.stdev(cts_final, 34)
dvl_den = ta.stdev(cts_final, 288)
DVL = bar_index < 300 ? na : math.min(1.0, math.max(0.0, dvl_num / math.max(dvl_den, 1e-8)))

// ============================= EXECUTION =============================
allow_orders = ORDERS_ENABLED and QTY_GATE > 0.0
unit_final = 1.0
unit_final_gated = unit_final * QTY_GATE

long_signal = false
short_signal = false

if allow_orders
    na

// ============================= TELEMETRY =============================
groupDisp = "Display"
SHOW_TABLE = input.bool(true, "Show Telemetry", group=groupDisp)
SHOW_RISK_BG = input.bool(true, "Show Risk BG", group=groupDisp)
COMPACT_VIEW = input.bool(false, "Compact", group=groupDisp)
LIVE_TICK_UPDATES = input.bool(true, "Telemetry: Update Every Tick", group=groupDisp)
SHOW_G5_DBG = input.bool(false, "Show G5 Debug (Row-13)", group=groupDisp)

bgcolor(SHOW_RISK_BG and risk_off_state ? color.new(color.red, 95) : na)

basis_ema = ta.ema(close, 21)
plot(basis_ema, "Basis EMA", color.new(color.blue,70))
plot_count := plot_count + 1

plot(htf_ema20, "HTF EMA20", color.new(color.orange, 80))
plot_count := plot_count + 1

// ============================= TABLE FIX: GLOBAL VAR + TICK-REFRESH SAFE =============================
var table t = na

// Create table once (persistent) - capacity reduced to 32 rows
if SHOW_TABLE and na(t)
    t := table.new(position.top_right, 2, COMPACT_VIEW?12:32, 
         bgcolor=color.new(color.black,80), border_color=color.gray, border_width=1)

// Update cells on last bar (replay) or every tick (live)
should_draw = SHOW_TABLE and (barstate.islast or (LIVE_TICK_UPDATES and barstate.isrealtime))
if should_draw
    
 // Row-0: Header + Build (STATIC for reliability - update manually per sprint)
    banner = "ATLAS Apex 2.3 — Sprint-1 | Pine:v5"
    table.cell(t, 0, 0, banner, text_color=color.white, bgcolor=color.new(color.blue, 50))
    table.cell(t, 1, 0, "Build:S1-7f8e9a2", text_color=color.white, bgcolor=color.new(color.blue, 50))
    
    table.cell(t,0,1,"H",text_color=color.white)
    table.cell(t,1,1,str.tostring(H,"#.###"))
    table.cell(t,0,2,"E",text_color=color.white)
    table.cell(t,1,2,str.tostring(E,"#.###"))
    table.cell(t,0,3,"K",text_color=color.white)
    table.cell(t,1,3,str.tostring(K,"#.###"))
    table.cell(t,0,4,"RV",text_color=color.white)
    table.cell(t,1,4,str.tostring(RV,"#.###"))
    table.cell(t,0,5,"global_damp",text_color=color.white)
    table.cell(t,1,5,str.tostring(global_damp,"#.###"))
    
    mode_val = allow_orders ? "Strategy ✓" : "Indicator"
    table.cell(t,0,6,"Mode",text_color=color.white)
    table.cell(t,1,6,mode_val)
    
    ff_val = (FF_RV?"R":"—")+"/"+(FF_PID?"P":"—")+"/"+(FF_SANDBOX?"S":"—")
    table.cell(t,0,7,"FF_RV/PID/SBX",text_color=color.white)
    table.cell(t,1,7,ff_val)
    
    if not COMPACT_VIEW
        rv_val = str.tostring(rv_fast,"#.###")+"/"+str.tostring(rv_slow,"#.###")+"/"+str.tostring(rv_mom,"#.###")
        table.cell(t,0,8,"RVf/RVs/ΔRV",text_color=color.white)
        table.cell(t,1,8,rv_val)
        
        fsm_val = (risk_off_state?"1":"0")+" / "+str.tostring(riskoff_fuse)
        table.cell(t,0,9,"R-Off state/fuse",text_color=color.white)
        table.cell(t,1,9,fsm_val)
        
        gate_val = (gate1_pass?"✓":"×")+"/"+(gate2_pass?"✓":"×")+"/"+(gate3_pass?"✓":"×")+"/"+(gate5_pass?"✓":"×")
        table.cell(t,0,10,"G1/G2/G3/G5",text_color=color.white)
        table.cell(t,1,10,gate_val)
        
        block_val = blocked_by_risk?"risk":(blocked_by_neutral?"neutral":(blocked_by_cooldown?"cooldown":"—"))
        table.cell(t,0,11,"blocked_by",text_color=color.white)
        table.cell(t,1,11,block_val)
        
        dvl_str = na(DVL) ? "warmup" : str.tostring(DVL,"#.###")
        table.cell(t,0,12,"DVL",text_color=color.white)
        table.cell(t,1,12,dvl_str)
        
        // G5 Debug (Row-13, optional)
        g5_label = SHOW_G5_DBG ? "G5 dbg (need|ext|base)" : ""
        g5_value = SHOW_G5_DBG ? str.format("{0} | {1,number,#.##} | {2,number,#.##}", 
                                   need_htf_state ? "1" : "0", ext_abs, base_gate) : ""
        table.cell(t,0,13,g5_label,text_color=color.white)
        table.cell(t,1,13,g5_value)
        
        table.cell(t,0,14,"len_pt/ma_eff",text_color=color.white)
        table.cell(t,1,14,"— / —")
        table.cell(t,0,15,"mult_pt/ma_eff",text_color=color.white)
        table.cell(t,1,15,"— / —")
        table.cell(t,0,16,"mult_xv/dv_eff",text_color=color.white)
        table.cell(t,1,16,"— / —")
        table.cell(t,0,17,"cooldown_eff",text_color=color.white)
        table.cell(t,1,17,"—")
        table.cell(t,0,18,"vol_boost_eff",text_color=color.white)
        table.cell(t,1,18,"—")
        
        table.cell(t,0,19,"Slip μ/M/P95",text_color=color.white)
        table.cell(t,1,19,"—/—/— bps")
        table.cell(t,0,20,"MFOC",text_color=color.white)
        table.cell(t,1,20,"— bps")
        table.cell(t,0,21,"Guard",text_color=color.white)
        table.cell(t,1,21,"OK")
        
        table.cell(t,0,22,"EV / err",text_color=color.white)
        table.cell(t,1,22,"— / —")
        table.cell(t,0,23,"P / I / D",text_color=color.white)
        table.cell(t,1,23,"— / — / —")
        table.cell(t,0,24,"rs_scale_eff",text_color=color.white)
        table.cell(t,1,24,"—")
        table.cell(t,0,25,"gamma_eff",text_color=color.white)
        table.cell(t,1,25,"—")
        
        rt_val = na(runtime_ms) ? "n/a" : str.tostring(runtime_ms,"#.##")
        table.cell(t,0,26,"runtime_ms",text_color=color.white)
        table.cell(t,1,26,rt_val)
        table.cell(t,0,27,"request_count",text_color=color.white)
        table.cell(t,1,27,str.tostring(request_count))
        table.cell(t,0,28,"plot_count",text_color=color.white)
        table.cell(t,1,28,str.tostring(plot_count))
        
        bud_ok = (request_count<=35) and (plot_count<=64)
        bud_val = bud_ok ? "✓ OK" : "⚠ OVERSHOOT"
        bud_col = bud_ok ? color.green : color.orange
        table.cell(t,0,29,"Budget Status",text_color=color.white)
        table.cell(t,1,29,bud_val,text_color=bud_col)
        
        sb_val = FF_SANDBOX ? str.tostring(sandbox_warn_count) : "—"
        sb_col = sandbox_warn_count>0 ? color.orange : color.gray
        table.cell(t,0,30,"Sandbox Warns",text_color=color.white)
        table.cell(t,1,30,sb_val,text_color=sb_col)
        
        htf_val = na(htf_ema20) ? "⚠ NaN" : "✓ OK"
        htf_col = na(htf_ema20) ? color.red : color.green
        table.cell(t,0,31,"HTF Status",text_color=color.white)
        table.cell(t,1,31,htf_val,text_color=htf_col)