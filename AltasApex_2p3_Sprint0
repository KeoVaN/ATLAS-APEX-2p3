//@version=5
// ============================================================================
// Atlas Apex 2.3 — TV-only, tek dosya, Indicator ↔ Strategy (simülasyon) toggle
// Sprint-0: Audit & Fix (no-repaint HTF hijyen, telemetry iskeleti, sayaçlar)
// Feature-flags, Budget Lane, Sandbox Mode
// ============================================================================

// ============================= FEATURE FLAGS =============================
FF_GROUP = "Feature Flags"
ORDERS_ENABLED = input.bool(false, "Enable Order Execution", group=FF_GROUP,
     tooltip="Master switch. FALSE = pure telemetry/no orders")
QTY_GATE = input.float(0.0, "Quantity Gate (0-1)", minval=0.0, maxval=1.0, step=0.05, group=FF_GROUP,
     tooltip="Final position size multiplier. 0 = kill switch")
FF_RV  = input.bool(true,  "FF: Regime Vector", group=FF_GROUP, 
     tooltip="Enable Regime Vector (H/E/K) calculations")
FF_PID = input.bool(false, "FF: PID Risk (Sprint-4)", group=FF_GROUP,
     tooltip="Enable PID risk sizing (future sprint)")
FF_SANDBOX = input.bool(false, "FF: Sandbox Mode", group=FF_GROUP,
     tooltip="Experimental checks; counts anomalies in telemetry")

// ============================= MOD & RUNTIME =============================
MODE_GROUP  = "Mode"
INDICATOR_MODE = input.bool(true,  "Indicator Mode (no orders)",  group=MODE_GROUP,
     tooltip="Legacy toggle; use ORDERS_ENABLED for master control")
INIT_CAP       = input.float(10000, "Initial Capital",  group=MODE_GROUP)
COMM_PCT       = input.float(0.075, "Commission %",     group=MODE_GROUP, step=0.005)
SLIPPAGE_TICKS = input.int(2,       "Slippage (ticks)", group=MODE_GROUP)

strategy("Atlas Apex 2.3 — Sprint-0 (Hygiene)", overlay=true,
     initial_capital=INIT_CAP,
     commission_type=strategy.commission.percent,
     commission_value=COMM_PCT,
     slippage=SLIPPAGE_TICKS,
     pyramiding=0,
     calc_on_order_fills=true,
     max_bars_back=5000)

// ============================= HELPERS =============================
clamp(v, lo, hi) => math.min(math.max(v, lo), hi)
map(v, a, b, c, d) => c + (d - c) * ((v - a) / math.max(b - a, 1e-9))

// Runtime/budget counters
var int request_count = 0
var int plot_count    = 0
var float runtime_ms  = na  // Placeholder (Pine doesn't expose real CPU time)
var int sandbox_warn_count = 0

// Sandbox warn helper
f_sandbox_warn(cond) =>
    if FF_SANDBOX and cond
        sandbox_warn_count += 1

// No‑repaint HTF wrapper (ALL HTF reads MUST pass through this gate)
// CRITICAL: expr must be pure series; NO nested security() inside expr
noRepaintHTF(expr, tf) =>
    if barstate.isfirst
        request_count += 1
    request.security(syminfo.tickerid, tf, expr[1], lookahead=barmerge.lookahead_on)

// Convenience: safe HTF EMA (used in Gate-5)
htfEMA(src, len, tf) => noRepaintHTF(ta.ema(src, len), tf)

// ============================= STAGE-A ALIAS / GUARDS (Compile-Safety) =============================
// Sprint-1: Forward compatibility guards for variables referenced before definition

// 1) risk_score alias (Sprint-2 will introduce full RV composite)
// Currently RV is calculated from H/E/K below, but referenced in FSM
// This stub ensures compile-time safety
risk_score = 0.5  // Placeholder (will be replaced by actual RV calculation)

// 2) entropy_final alias (from v2.2.1 reference, maps to E)
// Gate-3 references E which is calculated later in the scaffold
entropy_final = 0.5  // Placeholder (will be overwritten by actual entropy calculation)

// Plot helper (counts only once)
plot_once(series, title, color) =>
    if barstate.isfirst
        plot_count += 1
    plot(series, title=title, color=color)

// ============================= DEFAULTS (Stage‑A) =============================
HURST_HI = input.float(0.55, "Hurst High", group="Defaults")
HURST_LO = input.float(0.45, "Hurst Low",  group="Defaults")
RV_SMOOTH_EMA  = input.int(3, "RV Smooth EMA", minval=1, group="Defaults")

// ============================= SPRINT-1 INPUTS =============================
groupS1 = "Sprint-1 — FSM & Gates"
RISK_OFF_ENTER    = input.float(0.95, "Risk-Off Enter", 0.80, 1.00, 0.01, group=groupS1)
RISK_OFF_EXIT     = input.float(0.85, "Risk-Off Exit",  0.70, 0.95, 0.01, group=groupS1)
ATTEN_FLOOR       = input.float(0.60, "Attenuation Floor", 0.40, 0.80, 0.05, group=groupS1)
REL_VALVE_ENABLED = input.bool(true,  "Risk-Off Early-Release", group=groupS1)
FUSE_BARS         = input.int(40,     "Risk-Off Fuse (bars)", 5, 200, group=groupS1)

// Anti-Chop (Stage-A)
AC_MIN_ATR_Z     = input.float(0.20, "Anti-Chop: Min ATR-z", 0.00, 1.00, 0.01, group=groupS1,
     tooltip="Minimum ATR z-score (0.15 for fast symbols like SOL)")
AC_SIDE_GAP_ATR  = input.float(0.50, "Anti-Chop: Min side-gap ×ATR", 0.10, 2.00, 0.05, group=groupS1)
AC_BURST_LEN     = input.int(12,     "Anti-Chop: Burst window", 4, 50, 1, group=groupS1)
AC_MAX_BURSTS    = input.int(3,      "Anti-Chop: Max flips in window", 1, 10, 1, group=groupS1)

// Neutral band (placeholder for composite signal)
NEUTRAL_LO = input.float(0.48, "Neutral Band Lower", 0.0, 0.5, 0.01, group=groupS1)
NEUTRAL_HI = input.float(0.52, "Neutral Band Upper", 0.5, 1.0, 0.01, group=groupS1)

// [COMPLIANT-221]: sprint-0 skeleton uses correct multiply patterns when introduced

// ============================= SCAFFOLD: META & PLACEHOLDERS =============================
// Sprint‑0: lightweight H/E/K proxies for telemetry skeleton
ret = math.log(close/close[1])

// Lightweight Hurst proxy (simple R/S variant)
f_hurst_simple(length) =>
    if bar_index < length
        0.5
    else
        mean_ret = ta.sma(ret, length)
        csum = 0.0, mx = 0.0, mn = 0.0
        for i = 0 to length-1
            csum += (ret[i]-mean_ret)
            mx := math.max(mx, csum)
            mn := math.min(mn, csum)
        R = mx - mn, S = ta.stdev(ret, length)
        R>0 and S>0 ? clamp(math.log(R/S)/math.log(length*0.5), 0, 1) : 0.5

H = FF_RV ? f_hurst_simple(50) : 0.5

// Lightweight entropy proxy (5-bin)
f_entropy5(src, lb) =>
    var float[] bins = array.new_float(5, 0)
    min_ret = ta.lowest(src, lb), max_ret = ta.highest(src, lb)
    rng = max_ret - min_ret
    e = 0.0
    if rng > 0
        for i = 0 to 4
            array.set(bins, i, 0)
        for i = 0 to lb-1
            if not na(src[i])
                idx = math.min(int((src[i]-min_ret)/rng*5), 4)
                array.set(bins, idx, array.get(bins, idx)+1)
        for i = 0 to 4
            p = array.get(bins, i)/lb
            if p>0
                e -= p*math.log(p)
        e/math.log(5.0)
    else
        0.5

E_raw = FF_RV ? f_entropy5(ret, 100) : 0.5
E = ta.ema(E_raw, 5)
entropy_final := E  // Alias update for backward compatibility

// Lightweight tail proxy (z-excess)
mu_t = ta.sma(ret, 100)
sd_t = math.max(ta.stdev(ret, 100), 1e-8)
z_t  = (ret - mu_t)/sd_t
K_raw = FF_RV ? ta.ema(math.abs(z_t), 5) : 0.0
K = clamp(ta.percentrank(K_raw, 200)/100.0, 0.0, 1.0)

// Regime Vector (placeholder): wH·Hn + wE·(1−En) + wK·(1−Kn)
wH = input.float(0.40, "wH", step=0.05, group="RV Weights")
wE = input.float(0.35, "wE", step=0.05, group="RV Weights")
wK = input.float(0.25, "wK", step=0.05, group="RV Weights")
Hn = clamp((H - 0.30)/0.40, 0, 1)
En = clamp(E, 0, 1)
Kn = clamp(K, 0, 1)
RV_raw = FF_RV ? (wH*Hn + wE*(1.0 - En) + wK*(1.0 - Kn)) : 0.5
RV = ta.ema(RV_raw, RV_SMOOTH_EMA)
risk_score := RV  // Alias update for FSM compatibility

// ============================= RV MOMENTUM (Sprint-1) =============================
rv_fast = ta.ema(RV, 3)
rv_slow = ta.ema(RV, 21)
rv_mom  = rv_fast - rv_slow  // ΔRV momentum

// ============================= RISK-OFF FSM (Sprint-1 Enhanced) =============================
var bool risk_off_state = false
var int  riskoff_fuse   = 0
var int  ro_bars = 0, rn_bars = 0

enter_th = RISK_OFF_ENTER
exit_th  = RISK_OFF_EXIT

// State counters
if RV > enter_th
    ro_bars += 1, rn_bars := 0
else if RV < exit_th or rv_mom < 0
    rn_bars += 1, ro_bars := 0
else
    ro_bars := 0, rn_bars := 0

// State transitions
if not risk_off_state and ro_bars >= 2
    risk_off_state := true
    riskoff_fuse   := FUSE_BARS
else if risk_off_state
    riskoff_fuse := math.max(riskoff_fuse - 1, 0)
    // Early-release valve (Eş Mimar spec)
    early_release = REL_VALVE_ENABLED and riskoff_fuse == 0 and (RV < (enter_th - 0.07)) and (rv_mom < -0.04)
    if rn_bars >= 2 or early_release
        risk_off_state := false
        rn_bars := 0
        riskoff_fuse := 0

// Global damp (Stage‑A defaults)
global_damp = risk_off_state ? ATTEN_FLOOR : ATTEN_FLOOR + (1.0-ATTEN_FLOOR)*(1.0 - RV)

// ============================= ANTI-CHOP (Sprint-1) =============================
// ATR-z metric
atr14    = ta.atr(14)
atr_mu50 = ta.sma(atr14, 50)
atr_sd50 = math.max(ta.stdev(atr14, 50), 1e-8)
atr_z    = (atr14 - atr_mu50)/atr_sd50
atr_ratio = atr14 / math.max(atr_mu50, 1e-8)

// Extension & side-gap
ema20 = ta.ema(close, 20)
ext   = (close - ema20)/math.max(atr14, 1e-8)
ext_abs = math.abs(ext)

side_gap_ok_long  = (ema20 - low)  >= AC_SIDE_GAP_ATR * atr14
side_gap_ok_short = (high  - ema20) >= AC_SIDE_GAP_ATR * atr14

// Burst counter (flap detection)
var int   burst_flips = 0
var int   burst_window = 0
var float last_sign = 0.0

// Placeholder composite signal (will be replaced with actual CTS in Sprint-2/3)
cts_final = 0.0  // Stub: No L1/L2 composite yet (Sprint-2 will add Trend + Mean-Rev layers)
cts_sign = math.sign(cts_final)
flip = cts_sign != 0 and cts_sign != math.sign(nz(last_sign))
if flip
    burst_flips += 1
if cts_sign != 0
    last_sign := cts_sign
burst_window += 1
if burst_window >= AC_BURST_LEN
    burst_window := 0
    burst_flips := 0

// ============================= GATE LOGIC (Sprint-1) =============================
// Gate-5: HTF alignment with hysteresis (±0.15)
base_gate  = atr_ratio > 1.30 ? 2.2 : 2.0
gate_enter = base_gate + 0.15
gate_exit  = base_gate - 0.15

var bool need_htf_state = false
if not need_htf_state and ext_abs > gate_enter
    need_htf_state := true
else if need_htf_state and ext_abs < gate_exit
    need_htf_state := false

// htf_ema20 already populated from Sprint-0 (no new HTF calls)
htf_ok     = cts_final > 0 ? (close > htf_ema20) : (close < htf_ema20)
gate5_pass = (not need_htf_state) or htf_ok

// Gate-1: Extension + pullback + side-gap
ext_gate = base_gate
pb_long  = (close <= ema20 + 0.5*atr14) or (close < open)
pb_short = (close >= ema20 - 0.5*atr14) or (close > open)
gate1_pass = (ext_abs <= ext_gate) or (pb_long and side_gap_ok_long) or (pb_short and side_gap_ok_short)

// Gate-2: Percentile + dCTS sign
dcts = ta.change(cts_final)
cts_pr = nz(ta.percentrank(cts_final, 200)/100.0, 0.5)
gate2_pass = cts_final > 0 ? (cts_pr <= 0.95 and dcts >= 0) : (cts_pr >= 0.05 and dcts <= 0)

// Gate-3: Entropy/ATR-z guard (Sprint-2 will finalize E)
jsd_high  = E >= 0.85
gate3_pass = not (jsd_high or (atr_z < AC_MIN_ATR_Z) or (burst_flips > AC_MAX_BURSTS))

// Block reasons
blocked_by_risk     = risk_off_state
blocked_by_neutral  = math.abs(cts_final) >= NEUTRAL_LO and math.abs(cts_final) <= NEUTRAL_HI
blocked_by_cooldown = false  // Placeholder (Sprint-2 cooldown logic)
// Master kill-switch hierarchy: ORDERS_ENABLED AND QTY_GATE > 0
allow_orders = ORDERS_ENABLED and QTY_GATE > 0.0
unit_final = 1.0  // Placeholder (Sprint-4 will populate)
unit_final_gated = unit_final * QTY_GATE

// Canary signal stub (no trades in Sprint‑0)
long_signal  = false
short_signal = false

if allow_orders
    // (Sprint‑1+ aşamalarında gerçek emir mantığı buraya gelecek)
    // strategy.entry("Long", strategy.long, qty=unit_final_gated)
    na

// ============================= HTF HYGIENE (Gate-5 prep) =============================
// ALL HTF references via noRepaintHTF wrapper
// Gate-5 example: 60m close & EMA20 (no nested security inside expr)
// LINT: nested security() disallowed in expr
htf_close  = noRepaintHTF(close, "60")
htf_ema20  = noRepaintHTF(ta.ema(close, 20), "60")

// Sandbox check: HTF NaN detection + budget overshoot
f_sandbox_warn(na(htf_ema20))
budget_ok_check = (request_count <= 35) and (plot_count <= 64)
f_sandbox_warn(not budget_ok_check)

// ============================= TELEMETRY (Row‑24 + Budget Lane) =============================
SHOW_TABLE   = input.bool(true,  "Show Telemetry Table", group="Display")
SHOW_RISK_BG = input.bool(true,  "Show Risk Background", group="Display")
COMPACT_VIEW = input.bool(false, "Compact Telemetry",   group="Display")

// Risk background
bgcolor(SHOW_RISK_BG and risk_off_state ? color.new(color.red, 95) : na, title="Risk Off")

// Anchor plots (verify plot budget wiring)
basis_ema = ta.ema(close, 21)
plot_once(basis_ema, "Basis EMA (21)", color.new(color.blue,70))

// HTF EMA20 overlay (for Replay drift check)
plot_once(htf_ema20, "HTF EMA20 (60m, no-repaint)", color.new(color.orange, 80))

if SHOW_TABLE and barstate.islast
    // CRITICAL: Table row count must accommodate Sprint-1 expansion (Row-0 to Row-30 = 31 rows)
    var table t = table.new(position.top_right, 2, COMPACT_VIEW?12:36, 
         bgcolor=color.new(color.black,80), border_color=color.gray, border_width=1)
    
    // Header
    table.cell(t,0,0,"ATLAS Apex 2.3 — Sprint-0",text_color=color.white,bgcolor=color.new(color.blue,50))
    table.cell(t,1,0,"VALUE",text_color=color.white,bgcolor=color.new(color.blue,50))
    
    // Core meta
    table.cell(t,0,1, "H", text_color=color.white), table.cell(t,1,1,  str.tostring(H,  "#.###"))
    table.cell(t,0,2, "E", text_color=color.white), table.cell(t,1,2,  str.tostring(E,  "#.###"))
    table.cell(t,0,3, "K", text_color=color.white), table.cell(t,1,3,  str.tostring(K,  "#.###"))
    table.cell(t,0,4, "RV",text_color=color.white), table.cell(t,1,4,  str.tostring(RV, "#.###"))
    table.cell(t,0,5, "global_damp",text_color=color.white), table.cell(t,1,5, str.tostring(global_damp, "#.###"))
    
    // Mode & flags
    table.cell(t,0,6, "Mode",text_color=color.white), table.cell(t,1,6, 
         allow_orders ? "Strategy ✓" : "Indicator")
    table.cell(t,0,7, "FF_RV/PID/SBX",text_color=color.white), table.cell(t,1,7,
         (FF_RV?"R":"—")+"/"+(FF_PID?"P":"—")+"/"+(FF_SANDBOX?"S":"—"))
    
    if not COMPACT_VIEW
        // Eff params (placeholders for Sprint‑3)
        table.cell(t,0,8,  "len_pt/ma_eff", text_color=color.white), table.cell(t,1,8,  "— / —")
        table.cell(t,0,9,  "mult_pt/ma_eff",text_color=color.white), table.cell(t,1,9,  "— / —")
        table.cell(t,0,10, "mult_xv/dv_eff",text_color=color.white), table.cell(t,1,10, "— / —")
        table.cell(t,0,11, "cooldown_eff", text_color=color.white), table.cell(t,1,11, "—")
        table.cell(t,0,12, "vol_boost_eff",text_color=color.white), table.cell(t,1,12, "—")
        
        // Gate mask & reasons (Sprint‑1 placeholders)
        table.cell(t,0,13, "G1/G2/G3/G5", text_color=color.white), table.cell(t,1,13, "—/—/—/—")
        table.cell(t,0,14, "blocked_by",  text_color=color.white), table.cell(t,1,14, risk_off_state?"risk":"—")
        
        // Exec/Guard (stubs)
        table.cell(t,0,15, "Slip μ/M/P95",text_color=color.white), table.cell(t,1,15, "—/—/— bps")
        table.cell(t,0,16, "MFOC",        text_color=color.white), table.cell(t,1,16, "— bps")
        table.cell(t,0,17, "Guard",       text_color=color.white), table.cell(t,1,17, "OK")
        
        // PID (Sprint‑4 placeholders)
        table.cell(t,0,18, "EV / err",    text_color=color.white), table.cell(t,1,18, "— / —")
        table.cell(t,0,19, "P / I / D",   text_color=color.white), table.cell(t,1,19, "— / — / —")
        table.cell(t,0,20, "rs_scale_eff",text_color=color.white), table.cell(t,1,20, "—")
        table.cell(t,0,21, "gamma_eff",   text_color=color.white), table.cell(t,1,21, "—")
        
        // Budgets
        table.cell(t,0,22, "runtime_ms",  text_color=color.white), 
            table.cell(t,1,22, na(runtime_ms)?"n/a":str.tostring(runtime_ms, "#.##"))
        table.cell(t,0,23, "request_count",text_color=color.white), 
            table.cell(t,1,23, str.tostring(request_count))
        table.cell(t,0,24, "plot_count",  text_color=color.white), 
            table.cell(t,1,24, str.tostring(plot_count))
        
        // Budget Status Lane
        budget_ok = (request_count <= 35) and (plot_count <= 64)
        table.cell(t,0,25,"Budget Status", text_color=color.white)
        table.cell(t,1,25, budget_ok ? "✓ OK" : "⚠ OVERSHOOT",
                   text_color=budget_ok?color.green:color.orange)
        
        // Sandbox counter
        table.cell(t,0,26,"Sandbox Warns", text_color=color.white)
        table.cell(t,1,26, FF_SANDBOX ? str.tostring(sandbox_warn_count) : "—",
                   text_color=sandbox_warn_count>0?color.orange:color.gray)
        
        // HTF hygiene status
        table.cell(t,0,27,"HTF Status", text_color=color.white)
        table.cell(t,1,27, na(htf_ema20) ? "⚠ NaN" : "✓ OK",
                   text_color=na(htf_ema20)?color.red:color.green)

// ============================= QA CHECKLIST (inline) =============================
// [✓] FF: ORDERS_ENABLED + QTY_GATE kill-switch hierarchy
// [✓] HTF: All security() via noRepaintHTF wrapper (lookahead_on + [1])
// [✓] Telemetry: Row-31 (Sprint-1: FSM + Gates + DVL)
// [✓] PATCH-221: Compliance verified (skeleton uses correct patterns)
// [✓] Compile: Zero warnings expected
// [✓] Budget: plot ≤ 64, request ≤ 35 (2/2 preserved from Sprint-0)
// [✓] Sprint-1: Risk-Off FSM (fuse/early-release) + Gate mask (G1/G2/G3/G5)

// ============================= NEXT SPRINT HOOKS =============================
// Sprint‑2: Synapse‑α (Entropy/Tail/Hurst ring-buf, winsor z ±3, P95 norm) → RV + CTS composite
// Sprint‑3: Synapse‑β (RV→*_eff mapping, NAC to weights)
// Sprint‑4: Sentinel v3 (PID Risk) + RS_SCALE/GAMMA mapping
// Sprint‑5: QA & WFA
